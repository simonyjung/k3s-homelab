---
# -- Provide a name in place of the default application name
open-webui:
  nameOverride: ""

  # -- Provide a namespace in place of the default release namespace
  namespaceOverride: ""

  ollama:
    # -- Automatically install Ollama Helm chart from https://otwld.github.io/ollama-helm/.
    # Use [Helm Values](https://github.com/otwld/ollama-helm/#helm-values) to configure
    # @section -- External Tools configuration
    enabled: false

  # -- Value of cluster domain
  clusterDomain: cluster.local

  # -- Additional custom labels to add to the Open WebUI deployment/statefulset metadata
  extraLabels: {}

  # -- Additional annotations to add to the Open WebUI deployment/statefulset metadata
  annotations: {}

  # -- Additional annotations to add to the Open WebUI pods
  podAnnotations: {}

  # -- Additional custom labels to add to the Open WebUI pods
  podLabels: {}

  # -- Number of Open WebUI replicas
  replicaCount: 1

  # -- Revision history limit for the workload manager (deployment).
  revisionHistoryLimit: 10

  # -- Priority class name for the Open WebUI pods
  priorityClassName: ""

  # -- Strategy for updating the workload manager: deployment or statefulset
  strategy: {}

  image:
    # -- Open WebUI image repository
    # @section -- Image configuration
    repository: ghcr.io/open-webui/open-webui
    # -- Open WebUI image tag (Open WebUI image tags can be found here: https://github.com/open-webui/open-webui)
    # @section -- Image configuration
    tag: ""
    # -- Open WebUI image pull policy
    # @section -- Image configuration
    pullPolicy: "IfNotPresent"
    # -- Use a slim version of the Open WebUI image
    # @section -- Image configuration
    useSlim: false

  # -- Configure imagePullSecrets to use private registry
  # ref: <https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry>
  # @section -- Image configuration
  imagePullSecrets: []
  # imagePullSecrets:
  # - name: myRegistryKeySecretName

  # -- Open WebUI container command (overrides default entrypoint)
  command: []

  # -- Open WebUI container arguments (overrides default)
  args: []

  serviceAccount:
    # -- Enable service account creation
    # @section -- Service Account configuration
    enable: true
    # -- If create is set to false, set `name` to existing service account name
    # @section -- Service Account configuration
    create: true
    # -- Service account name to use. If `ServiceAccount.create` is false,
    # this assumes an existing service account exists with the set name.
    # If not set and `serviceAccount.create` is true, a name is generated using the fullname template.
    # @section -- Service Account configuration
    name: "existing-sa"
    # -- Additional annotations to add to the ServiceAccount
    # @section -- Service Account configuration
    annotations: {}
    # -- Automount service account token for the Open WebUI pods
    # @section -- Service Account configuration
    automountServiceAccountToken: false

  # -- Probe for liveness of the Open WebUI container
  # ref: <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes>
  # @section -- Probes configuration
  livenessProbe: {}
  # livenessProbe:
  #   httpGet:
  #     path: /health
  #     port: http
  #   failureThreshold: 1
  #   periodSeconds: 10

  # -- Probe for readiness of the Open WebUI container
  # ref: <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes>
  # @section -- Probes configuration
  readinessProbe: {}
  # readinessProbe:
  #   httpGet:
  #     path: /health/db
  #     port: http
  #   failureThreshold: 1
  #   periodSeconds: 10

  # -- Probe for startup of the Open WebUI container
  # ref: <https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes>
  # @section -- Probes configuration
  startupProbe: {}
  # startupProbe:
  #   httpGet:
  #     path: /health
  #     port: http
  #   initialDelaySeconds: 30
  #   periodSeconds: 5
  #   failureThreshold: 20

  # -- Resource requests and limits for the Open WebUI container
  resources: {}

  copyAppData:
    # -- Open WebUI copy-app-data init container command (overrides default)
    command: []
    # -- Open WebUI copy-app-data init container arguments (overrides default)
    args: []
    # -- Resource requests and limits for the Open WebUI copy-app-data init container
    resources: {}

  managedCertificate:
    # -- Enable GKE Managed Certificate for Ingress TLS
    # @section -- Ingress configuration
    enabled: false
    # -- Name of the Managed Certificate resource to create
    # @section -- Ingress configuration
    name: "mydomain-chat-cert"  # You can override this name if needed
    # -- Domains to include in the Managed Certificate
    # @section -- Ingress configuration
    domains:
      - chat.example.com  # update to your real domain

  ingress:
    # -- Enable Ingress controller for Open WebUI
    # @section -- Ingress configuration
    enabled: false
    # -- Ingress class to use, e.g., for GKE Ingress use "gce", for NGINX Ingress use "nginx".
    # If using an Ingress class other than the default, ensure your cluster has the corresponding
    # Ingress controller installed and configured.
    # @section -- Ingress configuration
    class: ""
    # -- Use appropriate annotations for your Ingress controller, e.g., for NGINX:
    # @section -- Ingress configuration
    annotations: {}
    #   # Example for GKE Ingress
    #   kubernetes.io/ingress.class: "gce"
    #   kubernetes.io/ingress.global-static-ip-name: "open-webui-external-ip"
    #   you need to create this address in GCP console
    #   # Force HTTP to redirect to HTTPS
    #   nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    #   nginx.ingress.kubernetes.io/ssl-redirect: "true"
    #   nginx.ingress.kubernetes.io/permanent-redirect: "https://chat.example.com"
    #   networking.gke.io/managed-certificates: "mydomain-chat-cert"
    #   # nginx.ingress.kubernetes.io/rewrite-target: /
    # -- Host for the Ingress record
    # @section -- Ingress configuration
    host: "chat.example.com"  # update to your real domain
    # -- Additional hosts for the Ingress record
    # @section -- Ingress configuration
    additionalHosts: []
    # -- TLS configuration for the Ingress resource
    # @section -- Ingress configuration
    tls: false
    # -- TLS secret name for the Ingress record
    # @section -- Ingress configuration
    existingSecret: ""
    # -- Additional custom labels to add to the Ingress metadata
    # @section -- Ingress configuration
    extraLabels: {}
    # extraLabels:
    #   app.kubernetes.io/environment: "staging"

  persistence:
    # -- Enable persistence using PVC for Open WebUI data
    # @section -- Persistence configuration
    enabled: true
    # -- Size of the Open WebUI PVC
    # @section -- Persistence configuration
    size: 2Gi
    # -- Use existingClaim if you want to re-use an existing Open WebUI PVC instead of creating a new one
    # @section -- Persistence configuration
    existingClaim: ""
    # -- Subdirectory of Open WebUI PVC to mount. Useful if root directory is not empty.
    # @section -- Persistence configuration
    subPath: ""
    # -- If using multiple replicas, you must update accessModes to ReadWriteMany
    # @section -- Persistence configuration
    accessModes:
      - ReadWriteOnce
    # -- Storage class of the Open WebUI PVC
    # @section -- Persistence configuration
    storageClass: ""
    # -- Selector to match to get the volume bound to the claim
    # @section -- Persistence configuration
    selector: {}
    # -- Additional annotations to add to the PVC
    # @section -- Persistence configuration
    annotations: {}
    # -- Sets the storage provider, availables values are `local`, `s3`, `gcs` or `azure`
    # @section -- Persistence configuration
    provider: local
    s3:
      # -- Sets the access key ID for S3 storage
      # @section -- Amazon S3 Storage configuration
      accessKey: ""
      # -- Sets the secret access key for S3 storage (ignored if secretKeyExistingSecret is set)
      # @section -- Amazon S3 Storage configuration
      secretKey: ""
      # -- Set the secret access key for S3 storage from existing k8s secret
      # @section -- Amazon S3 Storage configuration
      accessKeyExistingSecret: ""
      # -- Set the secret access key for S3 storage from existing k8s secret key
      # @section -- Amazon S3 Storage configuration
      accessKeyExistingAccessKey: ""
      # -- Set the secret key for S3 storage from existing k8s secret
      # @section -- Amazon S3 Storage configuration
      secretKeyExistingSecret: ""
      # -- Set the secret key for S3 storage from existing k8s secret key
      # @section -- Amazon S3 Storage configuration
      secretKeyExistingSecretKey: ""
      # -- Sets the endpoint url for S3 storage
      # @section -- Amazon S3 Storage configuration
      endpointUrl: ""
      # -- Sets the region name for S3 storage
      # @section -- Amazon S3 Storage configuration
      region: ""
      # -- Sets the bucket name for S3 storage
      # @section -- Amazon S3 Storage configuration
      bucket: ""
      # -- Sets the key prefix for a S3 object
      # @section -- Amazon S3 Storage configuration
      keyPrefix: ""
    gcs:
      # -- Contents of Google Application Credentials JSON file
      # (ignored if appCredentialsJsonExistingSecret is set).
      # Optional - if not provided, credentials will be taken from the environment.
      # User credentials if run locally and Google Metadata server if run on a Google Compute Engine.
      # File can be generated for a service account following this guide:
      # https://developers.google.com/workspace/guides/create-credentials#service-account
      # @section -- Google Cloud Storage configuration
      appCredentialsJson: ""
      # -- Set the Google Application Credentials JSON file for Google Cloud Storage from existing secret
      # @section -- Google Cloud Storage configuration
      appCredentialsJsonExistingSecret: ""
      # -- Set the Google Application Credentials JSON file for Google Cloud Storage from existing secret key
      # @section -- Google Cloud Storage configuration
      appCredentialsJsonExistingSecretKey: ""
      # -- Sets the bucket name for Google Cloud Storage. Bucket must already exist
      # @section -- Google Cloud Storage configuration
      bucket: ""
    azure:
      # -- Sets the endpoint URL for Azure Storage
      # @section -- Azure Storage configuration
      endpointUrl: ""
      # -- Sets the container name for Azure Storage
      # @section -- Azure Storage configuration
      container: ""
      # -- Set the access key for Azure Storage (ignored if keyExistingSecret is set).
      # Optional - if not provided, credentials will be taken from the environment.
      # User credentials if run locally and Managed Identity if run in Azure services
      # @section -- Azure Storage configuration
      key: ""
      # -- Set the access key for Azure Storage from existing secret
      # @section -- Azure Storage configuration
      keyExistingSecret: ""
      # -- Set the access key for Azure Storage from existing secret key
      # @section -- Azure Storage configuration
      keyExistingSecretKey: ""

  # -- Node labels for pod assignment.
  nodeSelector: {}

  # -- Tolerations for pod assignment
  tolerations: []

  # -- Affinity for pod assignment
  affinity: {}

  # -- Topology Spread Constraints for pod assignment
  topologySpreadConstraints: []

  # -- HostAliases to be added to hosts-file of each container
  hostAliases: []

  service:
    # -- Service type to expose Open WebUI pods to cluster.
    # Options are ClusterIP, NodePort, LoadBalancer, or ExternalName
    # @section -- Service configuration
    type: ClusterIP
    # -- Additional annotations to add to the Service
    # @section -- Service configuration
    annotations: {}
    # -- Port to expose Open WebUI service on
    # @section -- Service configuration
    port: 80
    # -- Target port for the Open WebUI container
    # @section -- Service configuration
    containerPort: 8080
    # -- Node port to use if service type is NodePort
    # @section -- Service configuration
    nodePort: ""
    # -- Additional custom labels to add to the Service metadata
    # @section -- Service configuration
    labels: {}
    # -- Load balancer class to use if service type is LoadBalancer (e.g., for GKE use "gce")
    # @section -- Service configuration
    loadBalancerClass: ""

  # -- Configure database URL, needed to work with Postgres
  # (example: `postgresql://<user>:<password>@<service>:<port>/<database>`),
  # leave empty to use the default sqlite database. Alternatively, use extraEnvVars
  # to construct the database URL by setting the `DATABASE_TYPE`, `DATABASE_USER`,
  # `DATABASE_PASSWORD`, `DATABASE_HOST`, and `DATABASE_NAME` environment variables.

  databaseUrl: ""
